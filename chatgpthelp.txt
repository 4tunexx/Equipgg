Thanks — I scanned your repo and the pieces that matter for the “Signing in… (stuck)” problem. I can see how the front-end and back-end are wired and what’s likely going wrong. I can’t change your repo directly, but below I give:

A short diagnosis (most likely causes).

Exact tests you can run (so you’ll see where it gets stuck).

A robust replacement /api/auth/login server route you can paste (fixes several classes of server-side hangs).

Checklist + actions to make sure Steam/OAuth works too.

Follow the steps in order — each one either proves/fixes a cause or gives useful logs.

1) Quick diagnosis (what I found)

Your UI calls signIn(email,password) from auth-provider, which calls fetch('/api/auth/login', { POST }). If that fetch never resolves, the modal stays in the “Signing in…” state.

There are two login API flavors in the repo (/api/auth/login/route.ts and /api/auth/signin/route.ts). The app calls /api/auth/login. That route uses supabase.auth.signInWithPassword(...) and returns data.session.

Common causes for a forever-hanging fetch:

The server route throws before sending a response (env var missing and code throws). In that case fetch never receives JSON.

The server route is waiting on a 3rd-party call (timeout) and never returns (or times out on server).

Vercel function fails/crashes and the POST stalls.

CORS, cookie, or redirect behavior stops flow (less likely for same-origin relative fetch).

I inspected src/lib/supabase.ts — it throws if env vars are missing. If the build/run environment doesn’t have NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY, the server will throw before responding → the client will hang.

2) Quick checks to run now (in your browser and Codespaces) — do these first
A. Check browser network and console

Open DevTools → Network tab.

Click Sign in (so it gets stuck).

Find the /api/auth/login request:

Is the request shown?

Does it return a HTTP response? What status? What response body?

If there's no request at all, the problem is client-side before fetch.

Check Console for JS errors.

If the network request shows status 500 or the request never completes, proceed to server logs.

B. Reproduce server-side with curl (in Codespaces or your machine)

Run this from a terminal (change email/password to a valid account you made in Supabase):

curl -v -H "Content-Type: application/json" \
  -d '{"email":"test@equipgg.net","password":"test123"}' \
  https://<your-deploy-url-or-local>/api/auth/login


If curl returns JSON with error — note text.

If curl never returns or quickly responds with no body, look at server logs.

C. Check environment variables in Vercel (or local .env)

Make sure Vercel project settings include these (client-only vs server-only notes below):

NEXT_PUBLIC_SUPABASE_URL → Supabase Project URL (client safe)

NEXT_PUBLIC_SUPABASE_ANON_KEY → Supabase anon public key (client safe)

SUPABASE_SERVICE_ROLE_KEY → service role key (server-only; do not expose in browser)

If any are missing, the server code will throw when importing src/lib/supabase.ts.

3) Quick fix to find the error (add server logging)

If you want to see the server-side error quickly, add a quick try/catch logger to your /api/auth/login route or replace it with the robust version below. That will produce explicit JSON errors and never leave the client hanging.

4) Paste-in: robust replacement for /api/auth/login (server route)

This is a safe, clearer version that:

uses server-side Supabase client via SUPABASE_SERVICE_ROLE_KEY if present (better for server),

logs useful error reasons,

always returns JSON with status (no silent throws),

enforces a server-side timeout.

Replace src/app/api/auth/login/route.ts with this (or create it if missing):

// src/app/api/auth/login/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL || "";
const SUPABASE_ANON = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || "";
const SUPABASE_SERVICE = process.env.SUPABASE_SERVICE_ROLE_KEY || "";

// Create a server client if we have service role; otherwise use anon
const supabase = SUPABASE_SERVICE
  ? createClient(SUPABASE_URL, SUPABASE_SERVICE)
  : createClient(SUPABASE_URL, SUPABASE_ANON);

function jsonError(message: string, status = 500) {
  return NextResponse.json({ ok: false, error: message }, { status });
}

export async function POST(req: NextRequest) {
  try {
    // defensive checks
    if (!SUPABASE_URL || (!SUPABASE_ANON && !SUPABASE_SERVICE)) {
      console.error("Missing Supabase env vars");
      return jsonError("Server misconfiguration: missing supabase env keys", 500);
    }

    const body = await req.json().catch(() => null);
    if (!body) return jsonError("Invalid request body", 400);

    const email = String(body.email || "").trim().toLowerCase();
    const password = String(body.password || "");

    if (!email || !password) {
      return jsonError("Email and password required", 400);
    }

    // run sign-in with timeout (10s)
    const signInPromise = supabase.auth.signInWithPassword({ email, password });

    const data = await Promise.race([
      signInPromise,
      new Promise((_, reject) =>
        setTimeout(() => reject(new Error("Login timeout")), 10000)
      )
    ]) as any;

    // supabase returns { data, error } or throws — normalize
    if (!data || data.error || !data.data?.session && !data.session && !data.user) {
      // older supabase client returns { data, error }, newer returns {data, error} too
      // handle both shapes
      const errMsg =
        (data && data.error && data.error.message) ||
        (data && data.message) ||
        "Invalid credentials";
      console.error("Login failed:", errMsg);
      return jsonError(errMsg, 401);
    }

    // prefer shape data.data.session or data.session
    const session = (data.data && data.data.session) || data.session || null;
    const user = (data.data && data.data.user) || data.user || null;

    if (!session || !user) {
      console.error("Sign-in returned but missing session or user", { data });
      return jsonError("Authentication failed", 401);
    }

    // success response -> return session & user (server sets cookie)
    const response = NextResponse.json({ ok: true, user, session });

    // set httpOnly cookie for server auth reading (optional name)
    response.cookies.set("equipgg_session", session.access_token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      maxAge: 60 * 60 * 24 * 7,
      path: "/",
    });

    return response;
  } catch (err: unknown) {
    console.error("Login route error:", err instanceof Error ? err.message : err);
    return NextResponse.json(
      { ok: false, error: err instanceof Error ? err.message : "Internal server error" },
      { status: 500 }
    );
  }
}


Why this helps

It prevents server-side throw on missing env keys and returns useful JSON instead.

If your login was hanging because src/lib/supabase.ts threw during module import, this avoids that by using createClient inside route and checking env vars.

The code sets a cookie and returns JSON promptly so client has something to read.

5) If you install the route above, retest with these steps
A. On server (Codespaces), run local dev:
npm install
npm run dev
# or: NODE_OPTIONS="--max-old-space-size=2048" npm run dev

B. From a browser open http://localhost:3000, open DevTools → Network, click Sign In, observe /api/auth/login response and body. It should return {ok:true, user:..., session:...} or an error JSON. If you get an error JSON, look at the message.
C. Test with curl (again):
curl -v -H "Content-Type: application/json" \
  -d '{"email":"your@test","password":"yourpw"}' \
  http://localhost:3000/api/auth/login


Look at returned JSON and server terminal logs.

6) Steam/OAuth flow — why Steam sends you back to sign-in

I looked at src/app/api/auth/steam/route.ts. Two likely issues:

Supabase OAuth redirect vs custom OpenID: You are using Steam OpenID yourself rather than supabase OAuth helper. If Steam logs in but your server doesn’t create a server-side session (Supabase session), the client will be redirected back to /sign-in and still be unauthenticated.

Session cookie used is userId not Supabase session — that means your middleware/auth-checks that rely on Supabase session won't find a valid session token.

Fixes for Steam flow

Prefer Supabase’s OAuth provider if possible (supabase.auth.signInWithOAuth({ provider: 'steam', options: { redirectTo }})) and configure Steam in Supabase dashboard with keys + redirect URIs.

If you must use custom OpenID flow, after validating Steam and matching/creating user, create a Supabase session server-side or set the same cookie names your front-end checks (e.g. sb-access-token + sb-refresh-token), or call supabase.auth.api.setAuth? (Supabase server-side methods vary). The simple route is to redirect to a server-side endpoint that calls Supabase Admin API to issue session tokens for that user and then set the same cookies.

7) Extra checks & best-practices

In src/lib/supabase.ts you throw if env vars missing. That will crash imports. Consider deferring throws to runtime or using safer pattern (like the route I provided).

Make sure you’re not loading the supabase client during module import in code executed in edge environment that cannot access env.

Confirm the exact endpoint the client calls — auth-provider calls /api/auth/login. Make sure you edit that route (not /auth/signin).

Keep only one canonical login route — duplicate routes make debugging confusing.

8) If you want, I will:

Generate a PR-style patch for the above route.ts replacement so you can copy-paste it quickly. (Say “yes — patch please”.)

Also produce a small helper script you can paste into the client to log the JSON result of fetch('/api/auth/login') so you can see its output in the client (if you prefer client-side debugging first).