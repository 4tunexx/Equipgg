'use client';

import { createClient, PostgrestError, SupabaseClient } from '@supabase/supabase-js';

// Database types
export interface User {
  id: string;
  username: string;
  email: string;
  role: string;
  level: number;
  xp: number;
  coins: number;
  gems: number;
  created_at: string;
  updated_at: string;
}

export interface Activity {
  id: string;
  user_id: string;
  username: string;
  activity_type: string;
  activity_data?: Record<string, any> | null;
  amount?: number | null;
  item_name?: string | null;
  item_rarity?: string | null;
  game_type?: string | null;
  multiplier?: number | null;
  created_at: string;
}

export interface QueryOptions<T> {
  columns?: string;
  where?: Partial<T>;
  orderBy?: string;
  limit?: number;
}

export interface DatabaseError extends Error {
  code?: string;
  details?: string;
  hint?: string;
  message: string;
}

// Initialize the Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
    },
  }
) as SupabaseClient;

// Helper function to handle Supabase query errors
const handleQueryError = (error: PostgrestError | Error | unknown, context: string): never => {
  console.error(`Error in ${context}:`, error);
  if (error instanceof Error) {
    throw error;
  }
  throw new Error(`Database error in ${context}: ${(error as DatabaseError)?.message || 'Unknown error'}`);
};

const secureDb = {
  async select<T = any>(
    table: string,
    options: QueryOptions<T> = {}
  ): Promise<T[]> {
    try {
      let query = supabase.from(table).select(options.columns || '*');

      if (options.where) {
        Object.entries(options.where).forEach(([key, value]) => {
          query = query.eq(key, value);
        });
      }

      if (options.orderBy) {
        query = query.order(options.orderBy);
      }

      if (options.limit) {
        query = query.limit(options.limit);
      }

      const { data, error } = await query;

      if (error) {
        throw error;
      }

      return data as T[];
    } catch (error) {
      return handleQueryError(error, 'select');
    }
  },

  async insert<T = any>(table: string, data: Partial<T> | Partial<T>[]): Promise<T[]> {
    try {
      const { data: result, error } = await supabase
        .from(table)
        .insert(data)
        .select();

      if (error) {
        throw error;
      }

      return result as T[];
    } catch (error) {
      return handleQueryError(error, 'insert');
    }
  },

  async update<T = any>(
    table: string,
    where: Partial<T>,
    data: Partial<T>
  ): Promise<T[]> {
    try {
      const { data: result, error } = await supabase
        .from(table)
        .update(data)
        .match(where)
        .select();

      if (error) {
        throw error;
      }

      return result as T[];
    } catch (error) {
      return handleQueryError(error, 'update');
    }
  },

  async upsert<T = any>(
    table: string, 
    data: Partial<T> | Partial<T>[],
    onConflict?: string
  ): Promise<T[]> {
    try {
      const query = supabase
        .from(table)
        .upsert(data);

      if (onConflict) {
        query.onConflict(onConflict);
      }

      const { data: result, error } = await query.select();

      if (error) {
        throw error;
      }

      return result as T[];
    } catch (error) {
      return handleQueryError(error, 'upsert');
    }
  },

  async delete<T = any>(table: string, where: Partial<T>): Promise<T[]> {
    try {
      const { data: result, error } = await supabase
        .from(table)
        .delete()
        .match(where)
        .select();

      if (error) {
        throw error;
      }

      return result as T[];
    } catch (error) {
      return handleQueryError(error, 'delete');
    }
  },

  async findOne<T = any>(table: string, where: Partial<T>): Promise<T | null> {
    try {
      const { data, error } = await supabase
        .from(table)
        .select()
        .match(where)
        .limit(1)
        .single();

      if (error && error.code !== 'PGRST116') {
        throw error;
      }

      return data as T;
    } catch (error) {
      if ((error as PostgrestError)?.code === 'PGRST116') {
        return null;
      }
      return handleQueryError(error, 'findOne');
    }
  }
};

export default secureDb;
    }
  }
};

export default secureDb;
    }
  },

  // Type-safe update
  async update<T = any>(
    table: string,
    match: Partial<T>,
    data: Partial<T>
  ): Promise<T[]> {
    try {
      const { data: result, error } = await supabase
        .from(table)
        .update(data)
        .match(match)
        .select();

      if (error) throw error;
      return result as T[];
    } catch (error) {
      return handleQueryError(error, 'update');
    }
  },

  // Type-safe delete
  async delete<T = any>(
    table: string,
    match: Partial<T>
  ): Promise<T[]> {
    try {
      const { data: result, error } = await supabase
        .from(table)
        .delete()
        .match(match)
        .select();

      if (error) throw error;
      return result as T[];
    } catch (error) {
      return handleQueryError(error, 'delete');
    }
  },

  // Type-safe upsert
  async upsert<T = any>(
    table: string,
    data: Partial<T> | Partial<T>[],
    onConflict: string
  ): Promise<T[]> {
    try {
      const { data: result, error } = await supabase
        .from(table)
        .upsert(data, { onConflict })
        .select();

      if (error) throw error;
      return result as T[];
    } catch (error) {
      return handleQueryError(error, 'upsert');
    }
  },

  // Type-safe single row select
  async findOne<T = any>(
    table: string,
    match: Partial<T>
  ): Promise<T | null> {
    try {
      const { data, error } = await supabase
        .from(table)
        .select()
        .match(match)
        .limit(1)
        .single();

      if (error && error.code !== 'PGRST116') { // No rows returned is not an error
        throw error;
      }
      return data as T;
    } catch (error) {
      return handleQueryError(error, 'findOne');
    }
  }
};
    }
  },

  // Update data
  async update(table: string, data: any, match: any) {
    try {
      const { data: result, error } = await supabase
        .from(table)
        .update(data)
        .match(match)
        .select();

      if (error) throw error;
      return result;
    } catch (error) {
      handleQueryError(error, 'update');
    }
  },

  // Delete data
  async delete(table: string, match: any) {
    try {
      const { data, error } = await supabase
        .from(table)
        .delete()
        .match(match)
        .select();

      if (error) throw error;
      return data;
    } catch (error) {
      handleQueryError(error, 'delete');
    }
  },

  // Execute a raw query (use with caution, ensure it's parameterized)
  async raw(query: string) {
    try {
      const { data, error } = await supabase.rpc('execute_raw', { query });
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleQueryError(error, 'raw');
    }
  },

  // Get a single row
  async getOne(table: string, match: any) {
    try {
      const { data, error } = await supabase
        .from(table)
        .select()
        .match(match)
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      handleQueryError(error, 'getOne');
    }
  },

  // Count rows
  async count(table: string, match: any = {}) {
    try {
      const { count, error } = await supabase
        .from(table)
        .select('*', { count: 'exact', head: true })
        .match(match);

      if (error) throw error;
      return count;
    } catch (error) {
      handleQueryError(error, 'count');
    }
  },

  // Transaction support (if needed, implement with Supabase's procedures)
  async transaction(operations: (() => Promise<any>)[]) {
    // This would need to be implemented as a Postgres function/procedure
    // that Supabase can call via rpc
    throw new Error('Transactions not yet implemented');
  },
};

export default secureDb;